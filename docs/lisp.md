We use a custom Lisp variant to encode resources. We anticipate an ingame programming capability and we need formats for various resource files, including models, materials, constructions etc. A Lisp could fulfill all of these roles. Some Lisp implementations exhibit the ability for incremental compilation - Lisp requires intepretation due to its runtime code evaluation capability but parts of programs can be compiled with no effect on program correctness. So it stands to reason that resource files, no matter whether they are programs, properties, or models, could be used equivalently in either text or byte-code format.

To work out the necessary properties of our Lisp flavour we explain Lisp in gradually increasing detail until a specification becomes evident.

The concept of Lisp starts very simply, with 2 fundamental types, the list and the atom. The list is a node of a singly-linked-list, containing only a data pointer and a next pointer. The atom is a symbol. The symbol supports 1 operation: equality, checking whether 1 symbol is another. To the programmer they are represented by a name, and symbols are equal if and only if they have identical names. The list's pointers may each point to either an atom or a list. This presents the first implementation problem, because it is thus a dynamically typed system, which is unnatural in C++. There are 2 parts to this problem. The first is deciding how to get around C++'s static type correctness mechanisms (allowing us to use either a list or an atom in the same place), and the second is maintaining dynamic type correctness (allowing us to distinguish between a list and an atom).

void\*  
void\* pointers are a very blunt tool for the job. They can be casted from any pointer and to any pointer, allowing us to reject C++'s typing system entirely. They are not supposed to be used in most situations.

2 pointers
We could simply have 2 pointer fields for each link, making a total of 4 per list. This effectively doubles the size of list so is not ideal.

union  
A union is a data structure that holds 1 item, and that item is one of a specified selection of possible types. The union takes as much space as the biggest type. In this case we could use a union of atom\* and list\*. This has the advantage that the list is only the size of 2 pointers, which is as small as it can practically be. However, a union has no built-in way to determine what type it is currently holding. This could be solved by putting a variable alongside it, such as in the list structure, to signal the type. That way whenever we need to distinguish between them, we could use a simple conditional or switch on the flag variable. The way C++ works, however, this could make each list bigger by 2 bytes or more, even though we only need 2 bits. This would make up a significant portion of the list's size: being 2 pointers for a 32 bit system, the minimum size is 8 bytes.

There may be another way to signal type, using the fact that an atom could be smaller than a list, being one pointer if necessary. So what we could do is make the atom a struct of 2 pointers, with one of them being nullptr always.

It is sensible to make these atoms hold a pointer because the traditional implementation of the symbol equality operator is to checkk whether the symbols occupy the same memory - whether their pointers compare equal.

However, we need to consider what atoms do. Often they are simple symbols, but get any practical use out of a Lisp we require some extra variants. At a minimum we need built-in functions. This is technically all we need to make Lisp Turing-complete, but other types are very useful for practical purposes, such as numeric and string constants, and macro symbols. So, once we know that an item is an atom, we need to find out what kind of atom it is. So we need to store type information somewhere. So perhaps we could keep a type-flag that dually signals whether a pointer is an atom and what kind of atom it is. We could also do some trickery to keep this flag to 1 byte per list - namely by storing the flag for each of the 2 pointers in each half of the same byte.

What actually goes in a symbol though? We link to a symbol by pointing to some memory location, but what actually needs to be stored in that location. With the current system, we don't need anything to be stored there, but we do need each symbol's location to be unique so we have to allocate them anyway. However, there is another important thing to do with symbols, which is lookup. If a symbol is evaluated, it is supposed to evaluate to its lookup value. This doesn't technically have to be an operation on a symbol, because we can use the equality operator to implement lookup, but it is much more efficient to implement it as an operator. So, the first thing a symbol should contain is a pointer to its lookup value, which could be a list or an atom. Then we consider the textual representation of a symbol - symbols have names, and the name should be usable to access the symbol (for parsing), and the symbol should be usable to access the name (for printing). The first should probably be best implemented by a hash table, and the second by storing the string in the symbol.

So, a memory model presents itself. We have a hash table from names to symbols, where each symbol stores its name and a lookup pointer. We also have lists. But we don't know where to put them, or how to manage their memory. We could use the built in shared pointers, but they could add overhead.

Evidence suggests that compilers will tend to align data, with the consequence that there is no point in keeping extra data smaller than a pointer - the size of a list or atom will be a multiple of 4 bytes, so we may as well use the whole 4 bytes. With the list, we could use a byte for each type flag, which allows use to use the same flag type for the symbol's lookup value. This leaves 2 bytes in a list and 3 bytes in a symbol. The extra list bytes could be used for memory management purposes.

# Scope